{"version":3,"file":"syntaxhighlighter.min.js","sources":["../src/syntaxhighlighter.js"],"sourcesContent":["// AMD module for syntax highlighter\n\n// ver: 2.0 [2025.12.02] moving to new repo\n\ndefine(['jquery'], function($) {\n/**\n     * Escapuje znaki specjalne HTML.\n     * @param {string} raw - surowy kod\n     * @returns {string} - kod z encjami (&lt;, &gt;, &amp;)\n     */\n    function escape(raw) {\n        return $(\"<div>\").text(raw).html();\n    }\n\n/**\n* Code & params extractor\n* @param {jQuery} $block - jQuery object containing the code block\n* @returns {Object} - Extracted code and parameters\n*/\n    function extract($block) {\n        let code = $block.find('code.githubcode').first();\n        if(code.length === 0) {\n            return null;\n        }\n\n        let attrs = {};\n        $.each(code.prop(\"attributes\"), function() {\n            if (this.name !== \"class\") {\n                attrs[this.name] = this.value;\n            }\n        });\n        return {\n            code: code.text(),\n            classes: code.attr(\"class\") || \"\",\n            attrs: attrs\n        };\n    }\n\n/**\n* Podmienia zawartość <pre> na finalny <code>:\n* @param {Object} classes - klasy do dodania do elementu code\n* @param {Object} code - kod do sparsowania\n* @returns {string} newCode - sparsowany kod\n*/\n    function final(classes, code) {\n        return $(\"<code>\").attr(\"class\", classes).html(code);\n    }\n/**\n* Dzieli kod na linie i opakowuje każdą linię w span.line:\n* @param {Object} code - kod do sparsowania\n* @returns {string} newCode - sparsowany kod\n*/\n    function lines(code) {\n        let lines = code.replace(/\\n$/, \"\").split(\"\\n\");\n        let newCode = \"\";\n\n        lines.forEach(function(line) {\n            newCode += \"<span class='line'>\" +  escape(line) + \"</span>\\n\";\n        });\n        return newCode;\n    }\n\n    return {\n        init: function() {\n            $(\"pre:has(code.githubcode)\").each(function() {\n                let extractedCode = extract($(this));\n                if (!extractedCode) { return; }\n                else {\n                    window.console.log(\"Attributes:\", extractedCode.attrs);\n                }\n\n                let parsedCode = lines(extractedCode.code);\n                let newCode = final(extractedCode.classes, parsedCode);\n                $(this).empty().append(newCode);\n\n            });\n        }\n    };\n});"],"names":["define","$","lines","code","replace","split","newCode","forEach","line","raw","text","html","init","each","extractedCode","$block","find","first","length","attrs","prop","this","name","value","classes","attr","extract","window","console","log","parsedCode","empty","append"],"mappings":"AAIAA,6CAAO,CAAC,WAAW,SAASC,YAgDfC,MAAMC,UACPD,MAAQC,KAAKC,QAAQ,MAAO,IAAIC,MAAM,MACtCC,QAAU,UAEdJ,MAAMK,SAAQ,SAASC,UA9CXC,IA+CRH,SAAW,uBA/CHG,IA+CmCD,KA9CxCP,EAAE,SAASS,KAAKD,KAAKE,OA8C2B,gBAEhDL,cAGJ,CACHM,KAAM,WACFX,EAAE,4BAA4BY,MAAK,eAC3BC,uBA9CCC,YACTZ,KAAOY,OAAOC,KAAK,mBAAmBC,WACvB,IAAhBd,KAAKe,cACG,SAGPC,MAAQ,UACZlB,EAAEY,KAAKV,KAAKiB,KAAK,eAAe,WACV,UAAdC,KAAKC,OACLH,MAAME,KAAKC,MAAQD,KAAKE,UAGzB,CACHpB,KAAMA,KAAKO,OACXc,QAASrB,KAAKsB,KAAK,UAAY,GAC/BN,MAAOA,OA+BiBO,CAAQzB,EAAEoB,WACzBP,qBAEDa,OAAOC,QAAQC,IAAI,cAAef,cAAcK,WAGhDW,WAAa5B,MAAMY,cAAcX,MACjCG,SA5BDkB,QA4BiBV,cAAcU,QA5BtBrB,KA4B+B2B,WA3B5C7B,EAAE,UAAUwB,KAAK,QAASD,SAASb,KAAKR,WADpCqB,QAASrB,KA6BZF,EAAEoB,MAAMU,QAAQC,OAAO1B"}